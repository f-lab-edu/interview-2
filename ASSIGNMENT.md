## 1. 애플리케이션 실행 방법

```bash
pnpm install
pnpm dev
```

프로젝트를 빠르게 실행해볼 수 있도록 실행 방법을 가장 먼저 안내합니다.

## 2. 과제 설명

### 과제 목표

- 목표: 티켓팅 대기열 + 결제 플로우 구현 (이벤트 티켓 예매)
- 제공 사항: 페이지 구성/역할, MSW 기반 API 명세

### 과제 분석

- 핵심 사용자 흐름:
  - 티켓 목록 → 티켓 상세 → 대기열 → 결제 → 예매 완료
- 핵심 데이터/상태:
  - 공개 가능: 티켓 ID 등
  - 민감/세션성: 예매 토큰, 예매 완료 ID 등
- 제약/전제:
  - API는 MSW로 모킹되어 있으며, 실제 서버와의 통합보다는 **흐름 구현**이 목적

### 접근 전략

- UI/UX: 요구사항에 UI 명세가 없으므로 프로토타입(Figma ai 사용)을 먼저 만든 뒤 구현 방향을 확정
- 구조: 규모 확장을 고려해 디렉토리 구조를 먼저 설계
- 상태: 페이지 간 공유 값은 최소화하고, 공개/민감 정보에 따라 전달 방식을 분리
- 데이터 요청: 마운트 이후 요청으로 인한 체감 지연을 최소화하는 방향으로 구성

## 3. 스택

- **기본 제공**

  - Vite + React + TypeScript (boilerplate)

- **추가한 것**
  - Tailwind CSS

### 선택 이유

- **Vite + React + TypeScript**

  - 본 과제는 기본적으로 Vite 기반 SPA 환경이 제공되어 있었으며,  
    과제 범위 내에서는 환경을 변경하기보다 **주어진 구성 안에서 요구사항을 해결하는 데 집중**했습니다.

  - 상태 관리, 서버 상태 관리 등 추가 라이브러리 도입도 검토했으나,  
    현재 요구사항과 애플리케이션 규모를 고려했을 때  
    **React에서 제공하는 api와 상태 관리 방식으로 충분히 구현 가능하다고 판단하여 도입하지 않았습니다.**

- **Tailwind CSS**

  - UI 요구사항이 명확히 정의되지 않은 상황에서  
    빠르게 화면을 구성하고 반복적으로 수정하기에 적합하다고 판단했습니다.
  - 컴포넌트 단위 스타일을 간결하게 관리할 수 있어 과제 범위에 적합했습니다.

## 4. 디렉토리 구조

```bash
src
 ┣ app            # 페이지 진입점 (라우트 단위 화면)
 ┣ assets         # 컴포넌트에서 사용하는 정적 에셋
 ┃ ┗ icons        # 아이콘 컴포넌트 관리
 ┣ features       # 도메인(기능) 단위 코드 관리
 ┃ ┣ common       # 여러 페이지에서 공통으로 사용하는 코드
 ┃ ┃ ┣ components # 공통 UI 컴포넌트
 ┃ ┃ ┣ hooks      # 공통 커스텀 훅
 ┃ ┃ ┗ store.ts   # 공통 전역 상태
 ┃ ┣ queue        # 티켓팅 대기열 도메인
 ┃ ┃ ┣ components # 대기열 페이지 전용 컴포넌트
 ┃ ┃ ┣ hooks      # 대기열 페이지 전용 훅
 ┃ ┃ ┣ api.ts     # 대기열 관련 API 함수
 ┃ ┃ ┣ type.ts    # 대기열 관련 타입 정의
 ┃ ┃ ┗ index.tsx  # 대기열 페이지 컴포넌트
 ┣ lib            # 애플리케이션 전반에서 사용하는 모듈
 ┃ ┣ http.ts      # 공통 fetch 래퍼
 ┃ ┗ utils        # 공통 유틸 함수
 ┣ mocks          # MSW API 모킹
 ┣ routes         # 라우트 설정
 ┗ types          # 전역 타입 정의
```

본 프로젝트는 하나의 티켓팅 도메인 안에서  
사용자가 수행하는 주요 기능 단위(feature)를 기준으로 코드를 분리했습니다.

`queue`는 하나의 도메인을 의미하기보다는,  
티켓팅 과정에서 사용자가 수행하는  
하나의 유즈케이스(use-case)를 대표하는 폴더입니다.

실제 프로젝트 내부에는 이와 같은 방식으로  
여러 유즈케이스 단위의 feature들이 존재하며,  
각 feature는 페이지, API, 타입, 훅을 함께 관리합니다.

## 5. 구현 중점 사항

1.  React API 기반으로 핵심 로직을 커스텀 훅/유틸로 분리

    - useSyncExternalStore

      전역 상태(토큰 등)를 구독 기반으로 관리하여 컴포넌트 리렌더 범위 통제

    - createPortal

      다이얼로그를 DOM 계층과 분리해, 레이아웃/overflow 제약과 무관하게 안정적으로 노출되도록 구현

    - useEffect + setInterval

      대기열/만료 시간처럼 시간 흐름 기반 UI를 구현하되, unmount 시 정리(cleanup)되도록 구성

2.  예외 처리를 한 곳에서 읽히도록 “페이지 컴포넌트 흐름”을 정리

    - 에러가 발생했을 때 분기 처리가 산재하지 않도록,  
      `error/index.tsx`에서 가드 → 렌더링 → 액션 처리 순서로 흐름을 구조화

    - 네트워크 에러(HttpError)는 status 별로 처리 정책을 분리해(예: 만료/입력오류/미존재)  
      예측 가능한 UX를 유지

3.  페이지 진입 시 서버 데이터를 선로딩하여 초기 UX 개선

    - 페이지 마운트 이후 fetch로 인해 화면이 늦게 안정되는 문제를 줄이기 위해,  
      react-router-dom의 loader + useLoaderData 패턴을 적용

    - 라우트 매칭 시점에 필요한 데이터를 먼저 확보한 뒤 렌더링하여, 로딩/빈 화면 구간을 최소화

4.  기능 단위 기준으로 코드 탐색성을 확보

    - 디렉토리 구조는 “도메인”보다는 사용자가 수행하는 기능 단위(feature / use-case) 를 기준으로 분리

    - 하나의 티켓팅 도메인 안에서 대기열, 좌석선택, 결제 등 흐름이 분리되기 때문에,  
      유지보수 시 “어디를 고치면 되는지”가 빠르게 드러나는 구조를 목표

## 6. 개선점

1. 좌석 예매 동시성 처리 미흡

   좌석 예매 시 이미 다른 사용자에 의해 예매된 좌석인 경우,  
   에러 메시지와 함께 좌석 상태가 즉시 업데이트되도록 처리하지 못했습니다.

   현재 구현에서는 예외 메시지 노출에 그치며,  
   해당 좌석을 비활성화하거나 목록을 재요청해 상태를 동기화하는 처리가 누락되었습니다.

   실제 티켓팅 환경에서는 동시성 이슈가 빈번하므로,  
   에러 발생 시 좌석 데이터를 재조회하거나 서버 상태를 기준으로  
   UI를 즉시 갱신하는 구조가 필요하다고 판단합니다.

2. 민감 ID 전달 방식

   예매 완료 후 발급되는 예매 완료 ID를 URL 파라미터로 전달했습니다.  
   이는 외부 노출이 가능한 값으로, 민감 정보 관리 측면에서 적절하지 않은 선택이었습니다.

   예매 과정에서 사용한 토큰과 마찬가지로,  
   해당 ID 역시 상태로 관리하거나 서버에서 재검증하는 방식이 더 적절하다고 판단합니다.

3. 문자열 기반 네비게이션 처리

   라우팅 시 pathname.replace와 같은 문자열 기반 네비게이션 방식을 사용했습니다.  
   이 방식은 라우트 구조 변경 시 사이드 이펙트를 유발할 수 있고,  
   의도를 코드만으로 파악하기 어렵다는 단점이 있습니다.

   명시적인 라우트 정의를 기반으로 한 네비게이션 방식이  
   가독성과 유지보수 측면에서 더 나은 선택이었을 것으로 판단합니다.

4. useInterval 구현에서 불필요한 useEffect 사용

   타이머 로직을 구현하는 과정에서,  
   커스텀 훅 내부에 불필요한 useEffect가 포함된 구조로 작성되었습니다.

   해당 로직은 더 단순한 형태로 구현 가능하며,  
   의존성 관리 측면에서도 개선 여지가 있다고 판단합니다.

5. URL 파라미터 처리 일관성

   buildErrorSearch.ts에서  
   브라우저 API인 URLSearchParams와  
   react-router-dom의 API를 혼용하여 사용했습니다.

   기능적으로는 동작하지만,  
   라우팅과 URL 관리의 책임을 하나의 방식으로 통일하는 것이  
   코드 일관성과 유지보수 측면에서 더 바람직하다고 판단합니다.
